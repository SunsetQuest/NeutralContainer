@page "/posts/{PostId:int}"

@using System.ComponentModel.DataAnnotations
@using Microsoft.AspNetCore.Authorization
@using Microsoft.AspNetCore.Identity
@using Microsoft.EntityFrameworkCore
@using NeutralContainer.Data
@using NeutralContainer.Utilities
@using System.Text.Json
@inject ApplicationDbContext DbContext
@inject UserManager<ApplicationUser> UserManager
@inject CommentModerationService CommentModerationService

@attribute [Authorize]

<PageTitle>Post</PageTitle>

<div class="container py-4">
    @if (isLoading)
    {
        <p class="text-muted">Loading post…</p>
    }
    else if (post is null)
    {
        <h1>Post not found</h1>
        <p class="text-muted">We could not find that post.</p>
    }
    else
    {
        <h1>@postTitle</h1>
        <div class="ratio ratio-16x9 mb-4">
            <iframe src="@($"https://www.youtube.com/embed/{post.YouTubeVideoId}")"
                    title="YouTube video"
                    allowfullscreen></iframe>
        </div>
        <p class="text-muted">
            Posted @post.CreatedAt.ToLocalTime().ToString("MMM d, yyyy")
        </p>
        @if (!string.IsNullOrWhiteSpace(post.ContextText))
        {
            <div class="card mb-4">
                <div class="card-body">
                    <h2 class="h5">Context</h2>
                    <p class="mb-0">@post.ContextText</p>
                </div>
            </div>
        }
        <div class="card mb-4">
            <div class="card-body">
                <h2 class="h5">Response Agreement</h2>
                <div class="row g-3">
                    <div class="col-12 col-lg-6">
                        <h3 class="h6">What I’m looking for</h3>
                        @if (allowedFeedbackModes.Count == 0)
                        {
                            <p class="text-muted mb-0">No preferences selected.</p>
                        }
                        else
                        {
                            <ul class="mb-0">
                                @foreach (var item in allowedFeedbackModes)
                                {
                                    <li>@item</li>
                                }
                            </ul>
                        }
                    </div>
                    <div class="col-12 col-lg-6">
                        <h3 class="h6">Please avoid</h3>
                        @if (avoidanceModes.Count == 0)
                        {
                            <p class="text-muted mb-0">No specific avoid list.</p>
                        }
                        else
                        {
                            <ul class="mb-0">
                                @foreach (var item in avoidanceModes)
                                {
                                    <li>@item</li>
                                }
                            </ul>
                        }
                    </div>
                </div>

                @if (sensitivityFlags.Count > 0)
                {
                    <div class="mt-3">
                        <h3 class="h6">Sensitivity toggles</h3>
                        <ul class="mb-0">
                            @foreach (var item in sensitivityFlags)
                            {
                                <li>@item</li>
                            }
                        </ul>
                    </div>
                }

                @if (!string.IsNullOrWhiteSpace(post.CustomRulesText))
                {
                    <div class="mt-3">
                        <h3 class="h6">Custom notes</h3>
                        <p class="mb-0">@post.CustomRulesText</p>
                    </div>
                }

                <div class="mt-3">
                    <p class="mb-1"><strong>Visibility:</strong> @visibilityPolicyLabel</p>
                    <p class="mb-0"><strong>Moderation:</strong> @moderationLevelLabel</p>
                </div>
            </div>
        </div>

        <div class="card mb-4">
            <div class="card-body">
                <h2 class="h5">Leave a comment</h2>

                @if (isUserBlocked)
                {
                    <div class="alert alert-warning">
                        You have been blocked by the creator and cannot comment on this post.
                    </div>
                }
                @if (isUserSuspended)
                {
                    <div class="alert alert-warning">
                        @suspensionMessage
                    </div>
                }

                <EditForm EditContext="commentEditContext" OnValidSubmit="HandleValidCommentSubmit">
                    <DataAnnotationsValidator />
                    <ValidationSummary />

                    <div class="mb-3">
                        <label class="form-label" for="commentBody">Your comment</label>
                        <InputTextArea id="commentBody"
                                       class="form-control"
                                       rows="4"
                                       disabled="@(isUserBlocked || isUserSuspended)"
                                       @bind-Value="commentModel.Body" />
                        <ValidationMessage For="@(() => commentModel.Body)" />
                    </div>

                    @if (post.VisibilityPolicy == VisibilityPolicy.CommenterChoice)
                    {
                        <div class="mb-3">
                            <label class="form-label">Visibility</label>
                            <div class="form-check">
                                <InputRadio id="commentVisibilityPrivate"
                                            class="form-check-input"
                                            @bind-Value="commentModel.Visibility"
                                            disabled="@(isUserBlocked || isUserSuspended)"
                                            Value="CommentVisibility.Private" />
                                <label class="form-check-label" for="commentVisibilityPrivate">Private (creator only)</label>
                            </div>
                            <div class="form-check">
                                <InputRadio id="commentVisibilityPublic"
                                            class="form-check-input"
                                            @bind-Value="commentModel.Visibility"
                                            disabled="@(isUserBlocked || isUserSuspended)"
                                            Value="CommentVisibility.Public" />
                                <label class="form-check-label" for="commentVisibilityPublic">Public (shows on this post)</label>
                            </div>
                            <ValidationMessage For="@(() => commentModel.Visibility)" />
                        </div>
                    }
                    else if (post.VisibilityPolicy == VisibilityPolicy.PrivateOnly)
                    {
                        <p class="text-muted">This creator only accepts private feedback.</p>
                    }
                    else if (post.VisibilityPolicy == VisibilityPolicy.PublicOnly)
                    {
                        <p class="text-muted">Your comment will be visible publicly after approval.</p>
                    }

                    @if (!string.IsNullOrWhiteSpace(checkMessage))
                    {
                        <div class="alert @checkStyle">
                            <p class="mb-1">@checkMessage</p>
                            @if (checkReasons.Count > 0)
                            {
                                <ul class="mb-0">
                                    @foreach (var reason in checkReasons)
                                    {
                                        <li>@reason.Summary (@reason.TriggeredRule)</li>
                                    }
                                </ul>
                            }
                        </div>
                    }

                    @if (!string.IsNullOrWhiteSpace(checkError))
                    {
                        <div class="alert alert-danger">@checkError</div>
                    }

                    @if (!string.IsNullOrWhiteSpace(commentResultMessage))
                    {
                        <div class="alert @commentResultStyle">@commentResultMessage</div>
                    }

                    @if (!string.IsNullOrWhiteSpace(commentError))
                    {
                        <div class="alert alert-danger">@commentError</div>
                    }

                    <div class="d-flex flex-wrap gap-2">
                        <button class="btn btn-outline-secondary" type="button" @onclick="HandleCheckComment" disabled="@(isUserBlocked || isUserSuspended)">Check my comment</button>
                        <button class="btn btn-primary" type="submit" disabled="@(isUserBlocked || isUserSuspended)">Submit</button>
                    </div>
                </EditForm>
            </div>
        </div>

        @if (showPublicComments)
        {
            <div class="card mb-4">
                <div class="card-body">
                    <h2 class="h5">Public comments</h2>
                    @if (publicComments.Count == 0)
                    {
                        <p class="text-muted mb-0">No public comments yet.</p>
                    }
                    else
                    {
                        <div class="d-flex flex-column gap-3">
                            @foreach (var comment in publicComments)
                            {
                                <div class="border rounded p-3">
                                    <div class="d-flex justify-content-between align-items-start">
                                        <div>
                                            <strong>@comment.DisplayName</strong>
                                        </div>
                                        <small class="text-muted">@comment.CreatedAt.ToLocalTime().ToString("MMM d, yyyy")</small>
                                    </div>
                                    <p class="mb-0">@comment.Body</p>
                                </div>
                            }
                        </div>
                    }
                </div>
            </div>
        }
        else
        {
            <p class="text-muted">Public comments are disabled for this post.</p>
        }

        @if (showViewerPrivateComments)
        {
            <div class="card mb-4">
                <div class="card-body">
                    <h2 class="h5">Your private comments</h2>
                    <p class="text-muted">Only you, the creator, and admins can see these.</p>
                    <div class="d-flex flex-column gap-3">
                        @foreach (var comment in viewerPrivateComments)
                        {
                            <div class="border rounded p-3">
                                <div class="d-flex justify-content-between align-items-start mb-2">
                                    <span class="badge @GetViewerCommentBadgeClass(comment)">@GetViewerCommentLabel(comment)</span>
                                    <small class="text-muted">@comment.CreatedAt.ToLocalTime().ToString("MMM d, yyyy")</small>
                                </div>
                                <p class="mb-0">@comment.Body</p>
                            </div>
                        }
                    </div>
                </div>
            </div>
        }
    }
</div>

@code {
    [Parameter]
    public int PostId { get; set; }

    private Post? post;
    private bool isLoading = true;
    private string postTitle = "Untitled";
    private readonly List<string> allowedFeedbackModes = new();
    private readonly List<string> avoidanceModes = new();
    private readonly List<string> sensitivityFlags = new();
    private string visibilityPolicyLabel = string.Empty;
    private string moderationLevelLabel = string.Empty;
    private readonly List<CommentListItem> publicComments = new();
    private readonly List<ViewerCommentListItem> viewerPrivateComments = new();
    private readonly CommentComposerModel commentModel = new();
    private EditContext? commentEditContext;
    private string? commentResultMessage;
    private string? commentResultStyle;
    private string? commentError;
    private bool showPublicComments;
    private bool showViewerPrivateComments;
    private string? checkMessage;
    private string? checkStyle;
    private string? checkError;
    private readonly List<ModerationReason> checkReasons = new();
    private static readonly TimeSpan CommentRateLimitWindow = TimeSpan.FromMinutes(2);
    private const int CommentRateLimitCount = 3;
    private static readonly TimeSpan NewAccountHoldWindow = TimeSpan.FromHours(6);
    private const int NewAccountHoldCount = 2;
    private bool isUserBlocked;
    private bool isUserSuspended;
    private string suspensionMessage = "Your account is suspended and cannot post comments right now.";

    [CascadingParameter]
    private Task<AuthenticationState> AuthenticationStateTask { get; set; } = default!;

    protected override async Task OnParametersSetAsync()
    {
        isLoading = true;
        post = await DbContext.Posts
            .AsNoTracking()
            .FirstOrDefaultAsync(p => p.Id == PostId);
        postTitle = string.IsNullOrWhiteSpace(post?.Title) ? "Untitled" : post.Title;
        allowedFeedbackModes.Clear();
        avoidanceModes.Clear();
        sensitivityFlags.Clear();
        publicComments.Clear();
        viewerPrivateComments.Clear();
        showPublicComments = false;
        showViewerPrivateComments = false;

        if (post is not null)
        {
            allowedFeedbackModes.AddRange(DescribeFeedbackModes(post.AllowedFeedbackModes));
            avoidanceModes.AddRange(DescribeAvoidanceModes(post.AvoidanceModes));
            sensitivityFlags.AddRange(DescribeSensitivityFlags(post.SensitivityFlags));
            visibilityPolicyLabel = DescribeVisibilityPolicy(post.VisibilityPolicy);
            moderationLevelLabel = DescribeModerationLevel(post.ModerationLevel);
            showPublicComments = post.VisibilityPolicy is VisibilityPolicy.PublicOnly or VisibilityPolicy.CommenterChoice;
            commentResultMessage = null;
            commentResultStyle = null;
            commentError = null;
            checkMessage = null;
            checkStyle = null;
            checkError = null;
            checkReasons.Clear();
            commentModel.Body = string.Empty;
            commentEditContext = new EditContext(commentModel);
            commentModel.Visibility = post.VisibilityPolicy == VisibilityPolicy.PublicOnly
                ? CommentVisibility.Public
                : CommentVisibility.Private;

            await UpdateBlockStatusAsync();
            await UpdateSuspensionStatusAsync();

            if (showPublicComments)
            {
                await LoadPublicComments();
            }

            await LoadViewerPrivateComments();
        }
        isLoading = false;
    }

    private static IEnumerable<string> DescribeFeedbackModes(FeedbackMode modes)
    {
        if (modes.HasFlag(FeedbackMode.PresenceOnly))
        {
            yield return "Presence-only (witnessing; “I hear you”)";
        }

        if (modes.HasFlag(FeedbackMode.ReflectiveListening))
        {
            yield return "Reflective listening (summarize what you heard)";
        }

        if (modes.HasFlag(FeedbackMode.ClarifyingQuestions))
        {
            yield return "Clarifying questions (gentle, no fixing)";
        }

        if (modes.HasFlag(FeedbackMode.SharePerspective))
        {
            yield return "Share your perspective (non-prescriptive)";
        }

        if (modes.HasFlag(FeedbackMode.AdviceAllowed))
        {
            yield return "Suggestions/advice allowed";
        }

        if (modes.HasFlag(FeedbackMode.ResourcesAllowed))
        {
            yield return "Resources allowed";
        }
    }

    private static IEnumerable<string> DescribeAvoidanceModes(AvoidanceMode modes)
    {
        if (modes.HasFlag(AvoidanceMode.DiagnosingOrLabeling))
        {
            yield return "Diagnosing or labeling";
        }

        if (modes.HasFlag(AvoidanceMode.MoralizingOrShaming))
        {
            yield return "Moralizing or shaming";
        }

        if (modes.HasFlag(AvoidanceMode.PrescriptiveLanguage))
        {
            yield return "Prescriptive language if advice not allowed";
        }

        if (modes.HasFlag(AvoidanceMode.MinimizingOrDismissing))
        {
            yield return "Minimizing or dismissing";
        }

        if (modes.HasFlag(AvoidanceMode.PushingTowardResolution))
        {
            yield return "Pushing toward resolution if presence-only";
        }
    }

    private static IEnumerable<string> DescribeSensitivityFlags(SensitivityFlag flags)
    {
        if (flags.HasFlag(SensitivityFlag.ExtraGentleContainer))
        {
            yield return "Extra gentle container";
        }

        if (flags.HasFlag(SensitivityFlag.NoMentalHealthLabels))
        {
            yield return "No mental health labels";
        }

        if (flags.HasFlag(SensitivityFlag.NoRelationshipAdvice))
        {
            yield return "No relationship advice";
        }

        if (flags.HasFlag(SensitivityFlag.NoMedicalAdvice))
        {
            yield return "No medical advice";
        }
    }

    private static string DescribeVisibilityPolicy(VisibilityPolicy policy) => policy switch
    {
        VisibilityPolicy.PrivateOnly => "Private feedback only",
        VisibilityPolicy.PublicOnly => "Public feedback only",
        VisibilityPolicy.CommenterChoice => "Commenter chooses (with consent)",
        _ => "Unspecified"
    };

    private static string DescribeModerationLevel(ModerationLevel level) => level switch
    {
        ModerationLevel.High => "High (extra gentle)",
        ModerationLevel.Standard => "Standard",
        _ => "Standard"
    };

    private async Task LoadPublicComments()
    {
        if (post is null)
        {
            return;
        }

        var comments = await DbContext.Comments
            .AsNoTracking()
            .Include(comment => comment.CommenterUser)
            .Where(comment => comment.PostId == post.Id)
            .Where(comment => comment.ModerationStatus == CommentModerationStatus.Approved)
            .Where(comment => !comment.IsHidden)
            .Where(comment => comment.Visibility == CommentVisibility.Public)
            .OrderBy(comment => comment.CreatedAt)
            .Select(comment => new CommentListItem(
                comment.Body,
                comment.CreatedAt,
                string.IsNullOrWhiteSpace(comment.CommenterUser!.DisplayName)
                    ? comment.CommenterUser!.UserName ?? "Commenter"
                    : comment.CommenterUser!.DisplayName))
            .ToListAsync();

        publicComments.AddRange(comments);
    }

    private async Task LoadViewerPrivateComments()
    {
        if (post is null)
        {
            return;
        }

        var authState = await AuthenticationStateTask;
        var user = await UserManager.GetUserAsync(authState.User);
        if (user is null)
        {
            return;
        }

        if (user.Id == post.CreatorUserId)
        {
            return;
        }

        var comments = await DbContext.Comments
            .AsNoTracking()
            .Where(comment => comment.PostId == post.Id)
            .Where(comment => comment.CommenterUserId == user.Id)
            .Where(comment => comment.Visibility == CommentVisibility.Private)
            .Where(comment => comment.ModerationStatus != CommentModerationStatus.Rejected)
            .OrderBy(comment => comment.CreatedAt)
            .Select(comment => new ViewerCommentListItem(
                comment.Body,
                comment.CreatedAt,
                comment.ModerationStatus))
            .ToListAsync();

        if (comments.Count == 0)
        {
            return;
        }

        viewerPrivateComments.AddRange(comments);
        showViewerPrivateComments = true;
    }

    private async Task HandleValidCommentSubmit()
    {
        commentError = null;
        commentResultMessage = null;
        commentResultStyle = null;
        checkMessage = null;
        checkStyle = null;
        checkError = null;
        checkReasons.Clear();

        if (post is null)
        {
            commentError = "Unable to submit a comment because the post could not be loaded.";
            return;
        }

        if (commentEditContext is null)
        {
            commentError = "Unable to validate the comment form. Please refresh and try again.";
            return;
        }

        var authState = await AuthenticationStateTask;
        var user = await UserManager.GetUserAsync(authState.User);
        if (user is null)
        {
            commentError = "Unable to identify the current user. Please sign in again.";
            return;
        }

        await UpdateBlockStatusAsync();
        if (isUserBlocked)
        {
            commentError = "You have been blocked by the creator and cannot comment on this post.";
            return;
        }

        await UpdateSuspensionStatusAsync();
        if (isUserSuspended)
        {
            commentError = suspensionMessage;
            return;
        }

        var recentCommentCount = await DbContext.Comments
            .AsNoTracking()
            .Where(comment => comment.CommenterUserId == user.Id)
            .Where(comment => comment.CreatedAt >= DateTimeOffset.UtcNow.Subtract(CommentRateLimitWindow))
            .CountAsync();

        if (recentCommentCount >= CommentRateLimitCount)
        {
            commentError = "You are commenting too quickly. Please wait a moment before trying again.";
            return;
        }

        var visibility = post.VisibilityPolicy switch
        {
            VisibilityPolicy.PrivateOnly => CommentVisibility.Private,
            VisibilityPolicy.PublicOnly => CommentVisibility.Public,
            VisibilityPolicy.CommenterChoice => commentModel.Visibility,
            _ => CommentVisibility.Private
        };

        var moderationResult = CommentModerationService.Evaluate(post, commentModel.Body);
        moderationResult = await ApplyNewAccountHoldAsync(user, moderationResult);
        var comment = new Comment
        {
            PostId = post.Id,
            CommenterUserId = user.Id,
            Body = commentModel.Body.Trim(),
            Visibility = visibility,
            CommenterPublicConsent = visibility == CommentVisibility.Public,
            ModerationStatus = moderationResult.Status,
            ModerationReasonsJson = moderationResult.Reasons.Count == 0
                ? null
                : JsonSerializer.Serialize(moderationResult.Reasons)
        };

        DbContext.Comments.Add(comment);
        await DbContext.SaveChangesAsync();

        switch (moderationResult.Status)
        {
            case CommentModerationStatus.Approved:
                commentResultMessage = visibility == CommentVisibility.Public
                    ? "Thanks! Your comment is now visible publicly."
                    : "Thanks! Your comment was sent privately to the creator.";
                commentResultStyle = "alert-success";
                commentModel.Body = string.Empty;
                commentEditContext = new EditContext(commentModel);
                if (showPublicComments && visibility == CommentVisibility.Public)
                {
                    publicComments.Clear();
                    await LoadPublicComments();
                }
                break;
            case CommentModerationStatus.Held:
                commentResultMessage = BuildModerationMessage(
                    "Thanks! Your comment is pending review.",
                    moderationResult);
                commentResultStyle = "alert-warning";
                commentModel.Body = string.Empty;
                commentEditContext = new EditContext(commentModel);
                break;
            case CommentModerationStatus.Rejected:
                commentError = BuildModerationMessage(
                    "Your comment needs a rewrite before it can be submitted.",
                    moderationResult);
                break;
            default:
                commentResultMessage = "Thanks! Your comment was received.";
                commentResultStyle = "alert-success";
                commentModel.Body = string.Empty;
                commentEditContext = new EditContext(commentModel);
                break;
        }
    }

    private void HandleCheckComment()
    {
        checkError = null;
        checkMessage = null;
        checkStyle = null;
        checkReasons.Clear();

        if (post is null)
        {
            checkError = "Unable to check your comment because the post could not be loaded.";
            return;
        }

        if (commentEditContext is null)
        {
            checkError = "Unable to validate your comment. Please refresh and try again.";
            return;
        }

        if (isUserBlocked)
        {
            checkError = "You have been blocked by the creator and cannot comment on this post.";
            return;
        }

        if (isUserSuspended)
        {
            checkError = suspensionMessage;
            return;
        }

        if (!commentEditContext.Validate())
        {
            checkError = "Please fix the validation errors above before running the check.";
            return;
        }

        var moderationResult = CommentModerationService.Evaluate(post, commentModel.Body);
        if (moderationResult.Reasons.Count == 0)
        {
            checkMessage = "Looks aligned with the Response Agreement. You can submit when ready.";
            checkStyle = "alert-success";
            return;
        }

        checkReasons.AddRange(moderationResult.Reasons);
        checkMessage = moderationResult.Status switch
        {
            CommentModerationStatus.Rejected =>
                "This comment would likely be rejected. Consider revising before submitting.",
            CommentModerationStatus.Held =>
                "This comment may be held for review. Consider revising to better fit the agreement.",
            _ => "We noticed some potential issues. Consider revising before submitting."
        };
        checkStyle = "alert-warning";
    }

    private static string BuildModerationMessage(string baseMessage, CommentModerationResult result)
    {
        if (result.Reasons.Count == 0)
        {
            return baseMessage;
        }

        var summary = string.Join(" ", result.Reasons.Select(reason => reason.Summary));
        return $"{baseMessage} {summary}";
    }

    private async Task UpdateBlockStatusAsync()
    {
        isUserBlocked = false;

        if (post is null)
        {
            return;
        }

        var authState = await AuthenticationStateTask;
        var user = await UserManager.GetUserAsync(authState.User);
        if (user is null)
        {
            return;
        }

        if (user.Id == post.CreatorUserId)
        {
            return;
        }

        isUserBlocked = await DbContext.CreatorBlocks
            .AsNoTracking()
            .AnyAsync(block => block.CreatorUserId == post.CreatorUserId && block.BlockedUserId == user.Id);
    }

    private async Task UpdateSuspensionStatusAsync()
    {
        isUserSuspended = false;
        suspensionMessage = "Your account is suspended and cannot post comments right now.";

        var authState = await AuthenticationStateTask;
        var user = await UserManager.GetUserAsync(authState.User);
        if (user is null)
        {
            return;
        }

        if (!user.IsSuspended)
        {
            return;
        }

        if (user.SuspendedUntil.HasValue && user.SuspendedUntil <= DateTimeOffset.UtcNow)
        {
            return;
        }

        isUserSuspended = true;
        if (!string.IsNullOrWhiteSpace(user.SuspensionReason))
        {
            suspensionMessage = $"Your account is suspended: {user.SuspensionReason}";
        }
    }

    private async Task<CommentModerationResult> ApplyNewAccountHoldAsync(ApplicationUser user, CommentModerationResult result)
    {
        if (user.CreatedAt == default)
        {
            return result;
        }

        if (DateTimeOffset.UtcNow - user.CreatedAt > TimeSpan.FromDays(7))
        {
            return result;
        }

        var recentCommentCount = await DbContext.Comments
            .AsNoTracking()
            .Where(comment => comment.CommenterUserId == user.Id)
            .Where(comment => comment.CreatedAt >= DateTimeOffset.UtcNow.Subtract(NewAccountHoldWindow))
            .CountAsync();

        if (recentCommentCount < NewAccountHoldCount)
        {
            return result;
        }

        if (result.Status == CommentModerationStatus.Rejected)
        {
            return result;
        }

        var reasons = result.Reasons.ToList();
        reasons.Add(new ModerationReason(
            "new_account_spam_risk",
            "New account activity triggered a manual review hold.",
            "New account rate check",
            ModerationSeverity.Low,
            0.55));

        return new CommentModerationResult(CommentModerationStatus.Held, reasons);
    }

    private sealed record CommentListItem(string Body, DateTimeOffset CreatedAt, string DisplayName);

    private static string GetViewerCommentLabel(ViewerCommentListItem comment) => comment.Status switch
    {
        CommentModerationStatus.Held => "Pending review",
        CommentModerationStatus.Flagged => "Flagged",
        CommentModerationStatus.Approved => "Approved",
        _ => "Pending review"
    };

    private static string GetViewerCommentBadgeClass(ViewerCommentListItem comment) => comment.Status switch
    {
        CommentModerationStatus.Held => "text-bg-warning",
        CommentModerationStatus.Flagged => "text-bg-danger",
        CommentModerationStatus.Approved => "text-bg-success",
        _ => "text-bg-secondary"
    };

    private sealed record ViewerCommentListItem(string Body, DateTimeOffset CreatedAt, CommentModerationStatus Status);

    private sealed class CommentComposerModel : IValidatableObject
    {
        [Required]
        [MaxLength(2000)]
        public string Body { get; set; } = string.Empty;

        [Required]
        public CommentVisibility Visibility { get; set; } = CommentVisibility.Private;

        public IEnumerable<ValidationResult> Validate(ValidationContext validationContext)
        {
            var trimmedBody = Body?.Trim() ?? string.Empty;

            if (trimmedBody.Length == 0)
            {
                yield return new ValidationResult(
                    "Comment body is required.",
                    new[] { nameof(Body) });
                yield break;
            }

            if (trimmedBody.Length < 10)
            {
                yield return new ValidationResult(
                    "Comment must be at least 10 characters.",
                    new[] { nameof(Body) });
            }
        }
    }
}
