@page "/posts/{PostId:int}"
@rendermode @(new InteractiveServerRenderMode(prerender: false))

@using System.ComponentModel.DataAnnotations
@using Microsoft.AspNetCore.Authorization
@using Microsoft.AspNetCore.Identity
@using Microsoft.EntityFrameworkCore
@using NeutralContainer.Data
@using NeutralContainer.Utilities
@using System.Text.Json
@inject ApplicationDbContext DbContext
@inject UserManager<ApplicationUser> UserManager
@inject CommentModerationService CommentModerationService
@inject NavigationManager NavigationManager

@attribute [Authorize]

<PageTitle>Post</PageTitle>

<div class="container py-4">
    @if (isLoading)
    {
        <p class="text-muted">Loading post...</p>
    }
    else if (post is null)
    {
        <h1>Post not found</h1>
        <p class="text-muted">We could not find that post.</p>
    }
    else
    {
        <h1>@postTitle</h1>
        @if (post.PostType == PostType.YouTubeBacked)
        {
            if (string.IsNullOrWhiteSpace(post.YouTubeVideoId))
            {
                <div class="alert alert-warning mb-4">This post is missing a video link.</div>
            }
            else
            {
                <div class="ratio ratio-16x9 mb-4">
                    <iframe src="@($"https://www.youtube.com/embed/{post.YouTubeVideoId}")"
                            title="YouTube video"
                            allowfullscreen></iframe>
                </div>
            }

            @if (!string.IsNullOrWhiteSpace(youtubeLink))
            {
                <p class="mb-4">
                    <a href="@youtubeLink" target="_blank" rel="noreferrer">Open on YouTube</a>
                </p>
            }
        }
        else
        {
            <div class="mb-4">
                @if (string.IsNullOrWhiteSpace(post.ContextText))
                {
                    <p class="text-muted mb-0">No text was provided.</p>
                }
                else
                {
                    <p class="fs-5 mb-0">@post.ContextText</p>
                }
            </div>
        }
        <p class="text-muted">
            Posted @post.CreatedAt.ToLocalTime().ToString("MMM d, yyyy")
        </p>
        @if (isCreatorViewing)
        {
            <div class="mb-3 d-flex flex-wrap gap-2">
                <a class="btn btn-outline-secondary btn-sm" href="@creatorInboxLink">View in Inbox</a>
                <button class="btn btn-outline-danger btn-sm"
                        type="button"
                        @onclick="ToggleDeletePrompt">
                    Delete post
                </button>
            </div>

            @if (showDeletePrompt)
            {
                <div class="alert alert-warning">
                    <p class="mb-2">
                        This will permanently remove the post and its comments. This action cannot be undone.
                    </p>
                    @if (!string.IsNullOrWhiteSpace(deleteError))
                    {
                        <div class="alert alert-danger mb-2">@deleteError</div>
                    }
                    <div class="d-flex flex-wrap gap-2">
                        <button class="btn btn-danger btn-sm"
                                type="button"
                                @onclick="DeletePostAsync"
                                disabled="isDeleting">
                            @if (isDeleting)
                            {
                                <span>Deleting...</span>
                            }
                            else
                            {
                                <span>Confirm delete</span>
                            }
                        </button>
                        <button class="btn btn-outline-secondary btn-sm" type="button" @onclick="ToggleDeletePrompt">
                            Cancel
                        </button>
                    </div>
                </div>
            }
        }
        @if (post.PostType == PostType.YouTubeBacked && !string.IsNullOrWhiteSpace(post.ContextText))
        {
            <div class="card mb-4">
                <div class="card-body">
                    <h2 class="h5">Supporting text</h2>
                    <p class="mb-0">@post.ContextText</p>
                </div>
            </div>
        }
        <div class="card mb-4">
            <div class="card-body">
                <h2 class="h5">Response Agreement</h2>
                <div class="row g-3">
                    <div class="col-12 col-lg-6">
                        <h3 class="h6">What I'm looking for</h3>
                        @if (allowedFeedbackModes.Count == 0)
                        {
                            <p class="text-muted mb-0">No preferences selected.</p>
                        }
                        else
                        {
                            <ul class="mb-0">
                                @foreach (var item in allowedFeedbackModes)
                                {
                                    <li>@item</li>
                                }
                            </ul>
                        }
                    </div>
                    <div class="col-12 col-lg-6">
                        <h3 class="h6">Please avoid</h3>
                        @if (avoidanceModes.Count == 0)
                        {
                            <p class="text-muted mb-0">No specific avoid list.</p>
                        }
                        else
                        {
                            <ul class="mb-0">
                                @foreach (var item in avoidanceModes)
                                {
                                    <li>@item</li>
                                }
                            </ul>
                        }
                    </div>
                </div>

                @if (sensitivityFlags.Count > 0)
                {
                    <div class="mt-3">
                        <h3 class="h6">Sensitivity toggles</h3>
                        <ul class="mb-0">
                            @foreach (var item in sensitivityFlags)
                            {
                                <li>@item</li>
                            }
                        </ul>
                    </div>
                }

                @if (!string.IsNullOrWhiteSpace(post.CustomRulesText))
                {
                    <div class="mt-3">
                        <h3 class="h6">Custom notes</h3>
                        <p class="mb-0">@post.CustomRulesText</p>
                    </div>
                }

                <div class="mt-3">
                    <p class="mb-1"><strong>Visibility:</strong> @visibilityPolicyLabel</p>
                    <p class="mb-0"><strong>Moderation:</strong> @moderationLevelLabel</p>
                </div>
            </div>
        </div>

        <div class="card mb-4">
            <div class="card-body">
                <h2 class="h5">Leave a comment</h2>
                <div class="alert alert-secondary" role="status">
                    NeutralContainer is not crisis support. If you're in immediate danger or need urgent help,
                    contact local emergency services or a crisis line in your area.
                    <details class="mt-2">
                        <summary>Find crisis resources</summary>
                        <p class="text-muted mb-2">
                            Resources vary by region. If you are outside the areas listed, search for local crisis
                            hotlines or emergency services in your country.
                        </p>
                        <ul class="mb-2">
                            <li><strong>United States:</strong> <a href="https://988lifeline.org/" target="_blank" rel="noreferrer">988 Suicide &amp; Crisis Lifeline</a></li>
                            <li><strong>United Kingdom &amp; Ireland:</strong> <a href="https://www.samaritans.org/" target="_blank" rel="noreferrer">Samaritans</a></li>
                            <li><strong>Australia:</strong> <a href="https://www.lifeline.org.au/" target="_blank" rel="noreferrer">Lifeline</a></li>
                            <li><strong>Global directory:</strong> <a href="https://www.iasp.info/resources/Crisis_Centres/" target="_blank" rel="noreferrer">International Association for Suicide Prevention</a></li>
                        </ul>
                        <p class="mb-0">If you need urgent help, contact local emergency services.</p>
                    </details>
                </div>

                @if (isUserBlocked)
                {
                    <div class="alert alert-warning">
                        You have been blocked by the creator and cannot comment on this post.
                    </div>
                }
                @if (isUserSuspended)
                {
                    <div class="alert alert-warning">
                        @suspensionMessage
                    </div>
                }

                <EditForm EditContext="commentEditContext" OnValidSubmit="HandleValidCommentSubmit" FormName="commentForm">
                    <DataAnnotationsValidator />
                    <ValidationSummary />

                    <div class="mb-3">
                        <label class="form-label" for="commentBody">Your comment</label>
                        <InputTextArea id="commentBody"
                                       class="form-control"
                                       rows="4"
                                       disabled="@((isUserBlocked || isUserSuspended) ? "disabled" : null)"
                                       @bind-Value="commentModel.Body" />
                        <ValidationMessage For="@(() => commentModel.Body)" />
                    </div>

                    @if (post.VisibilityPolicy == VisibilityPolicy.CommenterChoice)
                    {
                        <div class="mb-3">
                            <label class="form-label">Visibility</label>
                            <InputRadioGroup @bind-Value="commentModel.Visibility">
                                <div class="form-check">
                                    <InputRadio id="commentVisibilityPrivate"
                                                class="form-check-input"
                                                disabled="@((isUserBlocked || isUserSuspended) ? "disabled" : null)"
                                                Value="CommentVisibility.Private" />
                                    <label class="form-check-label" for="commentVisibilityPrivate">Private (creator only)</label>
                                </div>
                                <div class="form-check">
                                    <InputRadio id="commentVisibilityPublic"
                                                class="form-check-input"
                                                disabled="@((isUserBlocked || isUserSuspended) ? "disabled" : null)"
                                                Value="CommentVisibility.Public" />
                                    <label class="form-check-label" for="commentVisibilityPublic">Public (shows on this post)</label>
                                </div>
                            </InputRadioGroup>
                            <ValidationMessage For="@(() => commentModel.Visibility)" />
                        </div>
                    }
                    else if (post.VisibilityPolicy == VisibilityPolicy.PrivateOnly)
                    {
                        <p class="text-muted">This creator only accepts private feedback.</p>
                    }
                    else if (post.VisibilityPolicy == VisibilityPolicy.PublicOnly)
                    {
                        <p class="text-muted">Your comment will be visible publicly after approval.</p>
                    }

                    <div class="mb-3">
                        <div class="form-check">
                            <InputCheckbox id="commentAcknowledgement"
                                           class="form-check-input"
                                           @bind-Value="commentModel.Acknowledged"
                                           disabled="@((isUserBlocked || isUserSuspended) ? "disabled" : null)" />
                            <label class="form-check-label" for="commentAcknowledgement">
                                I will respond within these boundaries.
                            </label>
                        </div>
                        <ValidationMessage For="@(() => commentModel.Acknowledged)" />
                    </div>

                    @if (!string.IsNullOrWhiteSpace(checkMessage))
                    {
                        <div class="alert @checkStyle">
                            <p class="mb-1">@checkMessage</p>
                            @if (checkReasons.Count > 0)
                            {
                                <ul class="mb-0">
                                    @foreach (var reason in checkReasons)
                                    {
                                        <li>@reason.Summary (@reason.TriggeredRule)</li>
                                    }
                                </ul>
                            }
                        </div>
                    }

                    @if (!string.IsNullOrWhiteSpace(checkError))
                    {
                        <div class="alert alert-danger">@checkError</div>
                    }

                    @if (!string.IsNullOrWhiteSpace(commentResultMessage))
                    {
                        <div class="alert @commentResultStyle">@commentResultMessage</div>
                    }

                    @if (!string.IsNullOrWhiteSpace(commentError))
                    {
                        <div class="alert alert-danger">@commentError</div>
                    }

                    <div class="d-flex flex-wrap gap-2">
                        <button class="btn btn-outline-secondary"
                                type="button"
                                @onclick="HandleCheckComment"
                                disabled="@((isUserBlocked || isUserSuspended) ? "disabled" : null)">
                            Check my comment
                        </button>
                        <button class="btn btn-primary"
                                type="submit"
                                disabled="@((isUserBlocked || isUserSuspended) ? "disabled" : null)">
                            Submit
                        </button>
                    </div>
                </EditForm>
            </div>
        </div>

        @if (showPublicComments)
        {
            @if (highlightedComments.Count > 0)
            {
                <div class="card mb-4">
                    <div class="card-body">
                        <h2 class="h5">Highlighted comments</h2>
                        <div class="d-flex flex-column gap-3">
                            @foreach (var comment in highlightedComments)
                            {
                                <div class="border rounded p-3 bg-light">
                                    <div class="d-flex justify-content-between align-items-start mb-2">
                                        <div>
                                            <strong>@comment.DisplayName</strong>
                                            <span class="badge text-bg-warning ms-2">Highlighted</span>
                                        </div>
                                        <small class="text-muted">@comment.CreatedAt.ToLocalTime().ToString("MMM d, yyyy")</small>
                                    </div>
                                    <p class="mb-0">@comment.Body</p>
                                </div>
                            }
                        </div>
                    </div>
                </div>
            }

            <div class="card mb-4">
                <div class="card-body">
                    <h2 class="h5">Public comments</h2>
                    @if (!string.IsNullOrWhiteSpace(reportMessage))
                    {
                        <div class="alert alert-success">@reportMessage</div>
                    }
                    @if (!string.IsNullOrWhiteSpace(reportError))
                    {
                        <div class="alert alert-danger">@reportError</div>
                    }
                    @if (publicComments.Count == 0)
                    {
                        <p class="text-muted mb-0">No public comments yet.</p>
                    }
                    else
                    {
                        <div class="d-flex flex-column gap-3">
                            @foreach (var comment in publicComments)
                            {
                                <div class="border rounded p-3">
                                    <div class="d-flex justify-content-between align-items-start">
                                        <div>
                                            <strong>@comment.DisplayName</strong>
                                            @if (comment.IsHighlighted)
                                            {
                                                <span class="badge text-bg-warning ms-2">Highlighted</span>
                                            }
                                        </div>
                                        <small class="text-muted">@comment.CreatedAt.ToLocalTime().ToString("MMM d, yyyy")</small>
                                    </div>
                                    <p class="mb-0">@comment.Body</p>
                                    <div class="mt-3">
                                        <button class="btn btn-sm btn-outline-warning"
                                                type="button"
                                                @onclick="(() => StartReport(comment.Id))">
                                            Report
                                        </button>
                                    </div>
                                    @if (reportCommentId == comment.Id)
                                    {
                                        <div class="mt-3">
                                            <label class="form-label" for="reportReason">Reason (optional)</label>
                                            <InputTextArea id="reportReason"
                                                           class="form-control"
                                                           rows="3"
                                                           @bind-Value="reportReason" />
                                            <div class="d-flex flex-wrap gap-2 mt-2">
                                                <button class="btn btn-warning btn-sm" type="button" @onclick="SubmitReportAsync">Submit report</button>
                                                <button class="btn btn-outline-secondary btn-sm" type="button" @onclick="CancelReport">Cancel</button>
                                            </div>
                                        </div>
                                    }
                                </div>
                            }
                        </div>
                    }
                </div>
            </div>
        }
        else
        {
            <p class="text-muted">Public comments are disabled for this post.</p>
        }

        @if (showViewerPrivateComments)
        {
            <div class="card mb-4">
                <div class="card-body">
                    <h2 class="h5">Your private comments</h2>
                    <p class="text-muted">Only you, the creator, and admins can see these.</p>
                    <div class="d-flex flex-column gap-3">
                        @foreach (var comment in viewerPrivateComments)
                        {
                            <div class="border rounded p-3">
                                <div class="d-flex justify-content-between align-items-start mb-2">
                                    <span class="badge @GetViewerCommentBadgeClass(comment)">@GetViewerCommentLabel(comment)</span>
                                    <small class="text-muted">@comment.CreatedAt.ToLocalTime().ToString("MMM d, yyyy")</small>
                                </div>
                                <p class="mb-0">@comment.Body</p>
                            </div>
                        }
                    </div>
                </div>
            </div>
        }
    }
</div>

@code {
    [Parameter]
    public int PostId { get; set; }

    private Post? post;
    private bool isLoading = true;
    private string postTitle = "Untitled";
    private readonly List<string> allowedFeedbackModes = new();
    private readonly List<string> avoidanceModes = new();
    private readonly List<string> sensitivityFlags = new();
    private string visibilityPolicyLabel = string.Empty;
    private string moderationLevelLabel = string.Empty;
    private readonly List<CommentListItem> publicComments = new();
    private readonly List<CommentListItem> highlightedComments = new();
    private readonly List<ViewerCommentListItem> viewerPrivateComments = new();
    private readonly CommentComposerModel commentModel = new();
    private EditContext? commentEditContext;
    private string? commentResultMessage;
    private string? commentResultStyle;
    private string? commentError;
    private bool showPublicComments;
    private bool showViewerPrivateComments;
    private string? checkMessage;
    private string? checkStyle;
    private string? checkError;
    private readonly List<ModerationReason> checkReasons = new();
    private static readonly TimeSpan CommentRateLimitWindow = TimeSpan.FromMinutes(2);
    private const int CommentRateLimitCount = 3;
    private static readonly TimeSpan ReportRateLimitWindow = TimeSpan.FromMinutes(10);
    private const int ReportRateLimitCount = 3;
    private static readonly TimeSpan NewAccountHoldWindow = TimeSpan.FromHours(6);
    private const int NewAccountHoldCount = 2;
    private bool isUserBlocked;
    private bool isUserSuspended;
    private string suspensionMessage = "Your account is suspended and cannot post comments right now.";
    private bool isCreatorViewing;
    private string? creatorInboxLink;
    private string? youtubeLink;
    private int? reportCommentId;
    private string? reportReason;
    private string? reportMessage;
    private string? reportError;
    private bool showDeletePrompt;
    private bool isDeleting;
    private string? deleteError;

    [CascadingParameter]
    private Task<AuthenticationState> AuthenticationStateTask { get; set; } = default!;

    protected override async Task OnParametersSetAsync()
    {
        isLoading = true;
        post = await DbContext.Posts
            .AsNoTracking()
            .FirstOrDefaultAsync(p => p.Id == PostId);
        postTitle = string.IsNullOrWhiteSpace(post?.Title) ? "Untitled" : post.Title;
        allowedFeedbackModes.Clear();
        avoidanceModes.Clear();
        sensitivityFlags.Clear();
        publicComments.Clear();
        highlightedComments.Clear();
        viewerPrivateComments.Clear();
        showPublicComments = false;
        showViewerPrivateComments = false;
        isCreatorViewing = false;
        creatorInboxLink = null;
        youtubeLink = null;

        if (post is not null)
        {
            var authState = await AuthenticationStateTask;
            var user = await UserManager.GetUserAsync(authState.User);
            isCreatorViewing = user is not null && user.Id == post.CreatorUserId;
            creatorInboxLink = isCreatorViewing ? $"/creator/inbox?postId={post.Id}" : null;
            youtubeLink = UiText.BuildYouTubeLink(post);

            allowedFeedbackModes.AddRange(UiText.DescribeFeedbackModes(post.AllowedFeedbackModes));
            avoidanceModes.AddRange(UiText.DescribeAvoidanceModes(post.AvoidanceModes));
            sensitivityFlags.AddRange(UiText.DescribeSensitivityFlags(post.SensitivityFlags));
            visibilityPolicyLabel = UiText.DescribeVisibilityPolicy(post.VisibilityPolicy);
            moderationLevelLabel = UiText.DescribeModerationLevel(post.ModerationLevel);
            showPublicComments = post.VisibilityPolicy is VisibilityPolicy.PublicOnly or VisibilityPolicy.CommenterChoice;
            commentResultMessage = null;
            commentResultStyle = null;
            commentError = null;
            checkMessage = null;
            checkStyle = null;
            checkError = null;
            checkReasons.Clear();
            reportCommentId = null;
            reportReason = null;
            reportMessage = null;
            reportError = null;
            showDeletePrompt = false;
            isDeleting = false;
            deleteError = null;
            commentModel.Body = string.Empty;
            commentModel.Acknowledged = false;
            commentEditContext = new EditContext(commentModel);
            commentModel.Visibility = post.VisibilityPolicy == VisibilityPolicy.PublicOnly
                ? CommentVisibility.Public
                : CommentVisibility.Private;

            await UpdateBlockStatusAsync();
            await UpdateSuspensionStatusAsync();

            if (showPublicComments)
            {
                await LoadPublicComments();
            }

            await LoadViewerPrivateComments();
        }
        isLoading = false;
    }

    private async Task LoadPublicComments()
    {
        if (post is null)
        {
            return;
        }

        publicComments.Clear();
        highlightedComments.Clear();

        var comments = await DbContext.Comments
            .AsNoTracking()
            .Include(comment => comment.CommenterUser)
            .Where(comment => comment.PostId == post.Id)
            .Where(comment => comment.ModerationStatus == CommentModerationStatus.Approved)
            .Where(comment => !comment.IsHidden)
            .Where(comment => comment.Visibility == CommentVisibility.Public)
            .OrderBy(comment => comment.CreatedAt)
            .Select(comment => new CommentListItem(
                comment.Id,
                comment.Body,
                comment.CreatedAt,
                comment.IsHighlighted,
                string.IsNullOrWhiteSpace(comment.CommenterUser!.DisplayName)
                    ? comment.CommenterUser!.UserName ?? "Commenter"
                    : comment.CommenterUser!.DisplayName))
            .ToListAsync();

        publicComments.AddRange(comments.Where(comment => !comment.IsHighlighted));
        highlightedComments.AddRange(comments.Where(comment => comment.IsHighlighted));
    }

    private async Task LoadViewerPrivateComments()
    {
        if (post is null)
        {
            return;
        }

        var authState = await AuthenticationStateTask;
        var user = await UserManager.GetUserAsync(authState.User);
        if (user is null)
        {
            return;
        }

        if (user.Id == post.CreatorUserId)
        {
            return;
        }

        var comments = await DbContext.Comments
            .AsNoTracking()
            .Where(comment => comment.PostId == post.Id)
            .Where(comment => comment.CommenterUserId == user.Id)
            .Where(comment => comment.Visibility == CommentVisibility.Private)
            .Where(comment => comment.ModerationStatus != CommentModerationStatus.Rejected)
            .OrderBy(comment => comment.CreatedAt)
            .Select(comment => new ViewerCommentListItem(
                comment.Body,
                comment.CreatedAt,
                comment.ModerationStatus))
            .ToListAsync();

        if (comments.Count == 0)
        {
            return;
        }

        viewerPrivateComments.AddRange(comments);
        showViewerPrivateComments = true;
    }

    private async Task HandleValidCommentSubmit()
    {
        commentError = null;
        commentResultMessage = null;
        commentResultStyle = null;
        checkMessage = null;
        checkStyle = null;
        checkError = null;
        checkReasons.Clear();

        if (post is null)
        {
            commentError = "Unable to submit a comment because the post could not be loaded.";
            return;
        }

        if (commentEditContext is null)
        {
            commentError = "Unable to validate the comment form. Please refresh and try again.";
            return;
        }

        var authState = await AuthenticationStateTask;
        var user = await UserManager.GetUserAsync(authState.User);
        if (user is null)
        {
            commentError = "Unable to identify the current user. Please sign in again.";
            return;
        }

        await UpdateBlockStatusAsync();
        if (isUserBlocked)
        {
            commentError = "You have been blocked by the creator and cannot comment on this post.";
            return;
        }

        await UpdateSuspensionStatusAsync();
        if (isUserSuspended)
        {
            commentError = suspensionMessage;
            return;
        }

        var recentCommentWindowStart = DateTimeOffset.UtcNow.Subtract(CommentRateLimitWindow);
        var recentCommentCount = await DbContext.Comments
            .AsNoTracking()
            .Where(comment => comment.CommenterUserId == user.Id)
            .Where(comment => comment.CreatedAt >= recentCommentWindowStart)
            .CountAsync();

        if (recentCommentCount >= CommentRateLimitCount)
        {
            commentError = "You are commenting too quickly. Please wait a moment before trying again.";
            return;
        }

        var visibility = post.VisibilityPolicy switch
        {
            VisibilityPolicy.PrivateOnly => CommentVisibility.Private,
            VisibilityPolicy.PublicOnly => CommentVisibility.Public,
            VisibilityPolicy.CommenterChoice => commentModel.Visibility,
            _ => CommentVisibility.Private
        };

        var moderationResult = CommentModerationService.Evaluate(post, commentModel.Body);
        moderationResult = await ApplyNewAccountHoldAsync(user, moderationResult);
        var comment = new Comment
        {
            PostId = post.Id,
            CommenterUserId = user.Id,
            Body = commentModel.Body.Trim(),
            Visibility = visibility,
            CommenterPublicConsent = visibility == CommentVisibility.Public,
            ModerationStatus = moderationResult.Status,
            ModerationReasonsJson = moderationResult.Reasons.Count == 0
                ? null
                : JsonSerializer.Serialize(moderationResult.Reasons)
        };

        DbContext.Comments.Add(comment);
        await DbContext.SaveChangesAsync();

        switch (moderationResult.Status)
        {
            case CommentModerationStatus.Approved:
                commentResultMessage = visibility == CommentVisibility.Public
                    ? "Thanks! Your comment is now visible publicly."
                    : "Thanks! Your comment was sent privately to the creator.";
                commentResultStyle = "alert-success";
                commentModel.Body = string.Empty;
                commentModel.Acknowledged = false;
                commentEditContext = new EditContext(commentModel);
                if (showPublicComments && visibility == CommentVisibility.Public)
                {
                    await LoadPublicComments();
                }
                break;
            case CommentModerationStatus.Held:
                commentResultMessage = BuildModerationMessage(
                    "Thanks! Your comment is pending review.",
                    moderationResult);
                commentResultStyle = "alert-warning";
                commentModel.Body = string.Empty;
                commentModel.Acknowledged = false;
                commentEditContext = new EditContext(commentModel);
                break;
            case CommentModerationStatus.Rejected:
                commentError = BuildModerationMessage(
                    "Your comment needs a rewrite before it can be submitted.",
                    moderationResult);
                break;
            default:
                commentResultMessage = "Thanks! Your comment was received.";
                commentResultStyle = "alert-success";
                commentModel.Body = string.Empty;
                commentModel.Acknowledged = false;
                commentEditContext = new EditContext(commentModel);
                break;
        }
    }

    private void StartReport(int commentId)
    {
        reportCommentId = commentId;
        reportReason = string.Empty;
        reportMessage = null;
        reportError = null;
    }

    private void CancelReport()
    {
        reportCommentId = null;
        reportReason = null;
        reportMessage = null;
        reportError = null;
    }

    private async Task SubmitReportAsync()
    {
        reportMessage = null;
        reportError = null;

        if (post is null)
        {
            reportError = "Unable to submit a report because the post could not be loaded.";
            return;
        }

        if (!reportCommentId.HasValue)
        {
            reportError = "Select a comment to report.";
            return;
        }

        var authState = await AuthenticationStateTask;
        var user = await UserManager.GetUserAsync(authState.User);
        if (user is null)
        {
            reportError = "Unable to identify the current user. Please sign in again.";
            return;
        }

        if (!string.IsNullOrWhiteSpace(reportReason) && reportReason.Length > 1000)
        {
            reportError = "Report reasons must be 1,000 characters or fewer.";
            return;
        }

        var recentReportWindowStart = DateTimeOffset.UtcNow.Subtract(ReportRateLimitWindow);
        var recentReportCount = await DbContext.CommentReports
            .AsNoTracking()
            .Where(report => report.ReporterUserId == user.Id)
            .Where(report => report.CreatedAt >= recentReportWindowStart)
            .CountAsync();

        if (recentReportCount >= ReportRateLimitCount)
        {
            reportError = "You have submitted several reports recently. Please wait before sending another.";
            return;
        }

        var commentExists = await DbContext.Comments
            .AsNoTracking()
            .AnyAsync(comment =>
                comment.Id == reportCommentId.Value
                && comment.PostId == post.Id
                && comment.ModerationStatus == CommentModerationStatus.Approved
                && comment.Visibility == CommentVisibility.Public
                && !comment.IsHidden);

        if (!commentExists)
        {
            reportError = "That comment is no longer available to report.";
            return;
        }

        DbContext.CommentReports.Add(new CommentReport
        {
            CommentId = reportCommentId.Value,
            ReporterUserId = user.Id,
            Reason = string.IsNullOrWhiteSpace(reportReason) ? null : reportReason.Trim()
        });

        await DbContext.SaveChangesAsync();

        reportMessage = "Thanks. Your report has been sent to the admin queue.";
        reportCommentId = null;
        reportReason = null;
    }

    private void HandleCheckComment()
    {
        checkError = null;
        checkMessage = null;
        checkStyle = null;
        checkReasons.Clear();

        if (post is null)
        {
            checkError = "Unable to check your comment because the post could not be loaded.";
            return;
        }

        if (commentEditContext is null)
        {
            checkError = "Unable to validate your comment. Please refresh and try again.";
            return;
        }

        if (isUserBlocked)
        {
            checkError = "You have been blocked by the creator and cannot comment on this post.";
            return;
        }

        if (isUserSuspended)
        {
            checkError = suspensionMessage;
            return;
        }

        if (!commentEditContext.Validate())
        {
            checkError = "Please fix the validation errors above before running the check.";
            return;
        }

        var moderationResult = CommentModerationService.Evaluate(post, commentModel.Body);
        if (moderationResult.Reasons.Count == 0)
        {
            checkMessage = "Looks aligned with the Response Agreement. You can submit when ready.";
            checkStyle = "alert-success";
            return;
        }

        checkReasons.AddRange(moderationResult.Reasons);
        checkMessage = moderationResult.Status switch
        {
            CommentModerationStatus.Rejected =>
                "This comment would likely be rejected. Consider revising before submitting.",
            CommentModerationStatus.Held =>
                "This comment may be held for review. Consider revising to better fit the agreement.",
            _ => "We noticed some potential issues. Consider revising before submitting."
        };
        checkStyle = "alert-warning";
    }

    private static string BuildModerationMessage(string baseMessage, CommentModerationResult result)
    {
        if (result.Reasons.Count == 0)
        {
            return baseMessage;
        }

        var summary = string.Join(" ", result.Reasons.Select(reason => reason.Summary));
        return $"{baseMessage} {summary}";
    }

    private async Task UpdateBlockStatusAsync()
    {
        isUserBlocked = false;

        if (post is null)
        {
            return;
        }

        var authState = await AuthenticationStateTask;
        var user = await UserManager.GetUserAsync(authState.User);
        if (user is null)
        {
            return;
        }

        if (user.Id == post.CreatorUserId)
        {
            return;
        }

        isUserBlocked = await DbContext.CreatorBlocks
            .AsNoTracking()
            .AnyAsync(block => block.CreatorUserId == post.CreatorUserId && block.BlockedUserId == user.Id);
    }

    private async Task UpdateSuspensionStatusAsync()
    {
        isUserSuspended = false;
        suspensionMessage = "Your account is suspended and cannot post comments right now.";

        var authState = await AuthenticationStateTask;
        var user = await UserManager.GetUserAsync(authState.User);
        if (user is null)
        {
            return;
        }

        if (!user.IsSuspended)
        {
            return;
        }

        if (user.SuspendedUntil.HasValue && user.SuspendedUntil <= DateTimeOffset.UtcNow)
        {
            return;
        }

        isUserSuspended = true;
        if (!string.IsNullOrWhiteSpace(user.SuspensionReason))
        {
            suspensionMessage = $"Your account is suspended: {user.SuspensionReason}";
        }
    }

    private async Task<CommentModerationResult> ApplyNewAccountHoldAsync(ApplicationUser user, CommentModerationResult result)
    {
        if (user.CreatedAt == default)
        {
            return result;
        }

        if (DateTimeOffset.UtcNow - user.CreatedAt > TimeSpan.FromDays(7))
        {
            return result;
        }

        var newAccountHoldWindowStart = DateTimeOffset.UtcNow.Subtract(NewAccountHoldWindow);
        var recentCommentCount = await DbContext.Comments
            .AsNoTracking()
            .Where(comment => comment.CommenterUserId == user.Id)
            .Where(comment => comment.CreatedAt >= newAccountHoldWindowStart)
            .CountAsync();

        if (recentCommentCount < NewAccountHoldCount)
        {
            return result;
        }

        if (result.Status == CommentModerationStatus.Rejected)
        {
            return result;
        }

        var reasons = result.Reasons.ToList();
        reasons.Add(new ModerationReason(
            "new_account_spam_risk",
            "New account activity triggered a manual review hold.",
            "New account rate check",
            ModerationSeverity.Low,
            0.55));

        return new CommentModerationResult(CommentModerationStatus.Held, reasons);
    }

    private void ToggleDeletePrompt()
    {
        showDeletePrompt = !showDeletePrompt;
        deleteError = null;
    }

    private async Task DeletePostAsync()
    {
        if (isDeleting)
        {
            return;
        }

        deleteError = null;
        isDeleting = true;

        try
        {
            if (post is null)
            {
                deleteError = "Unable to delete the post because it could not be loaded.";
                return;
            }

            var authState = await AuthenticationStateTask;
            var user = await UserManager.GetUserAsync(authState.User);
            if (user is null)
            {
                deleteError = "Unable to identify the current user. Please sign in again.";
                return;
            }

            if (user.Id != post.CreatorUserId)
            {
                deleteError = "Only the creator of this post can delete it.";
                return;
            }

            var postToDelete = await DbContext.Posts
                .FirstOrDefaultAsync(current => current.Id == post.Id && current.CreatorUserId == user.Id);

            if (postToDelete is null)
            {
                deleteError = "We couldn't find the post to delete. It may have already been removed.";
                return;
            }

            DbContext.Posts.Remove(postToDelete);
            await DbContext.SaveChangesAsync();

            NavigationManager.NavigateTo("/");
        }
        catch (Exception)
        {
            deleteError = "Something went wrong while deleting the post. Please try again.";
        }
        finally
        {
            isDeleting = false;
        }
    }

    private sealed record CommentListItem(int Id, string Body, DateTimeOffset CreatedAt, bool IsHighlighted, string DisplayName);

    private static string GetViewerCommentLabel(ViewerCommentListItem comment) => comment.Status switch
    {
        CommentModerationStatus.Held => "Pending review",
        CommentModerationStatus.Flagged => "Flagged",
        CommentModerationStatus.Approved => "Approved",
        _ => "Pending review"
    };

    private static string GetViewerCommentBadgeClass(ViewerCommentListItem comment) => comment.Status switch
    {
        CommentModerationStatus.Held => "text-bg-warning",
        CommentModerationStatus.Flagged => "text-bg-danger",
        CommentModerationStatus.Approved => "text-bg-success",
        _ => "text-bg-secondary"
    };

    private sealed record ViewerCommentListItem(string Body, DateTimeOffset CreatedAt, CommentModerationStatus Status);

    public sealed class CommentComposerModel : IValidatableObject
    {
        [Required]
        [MaxLength(2000)]
        [CustomValidation(typeof(CommentComposerModel), nameof(ValidateBody))]
        public string Body { get; set; } = string.Empty;

        [Required]
        public CommentVisibility Visibility { get; set; } = CommentVisibility.Private;

        [Range(typeof(bool), "true", "true", ErrorMessage = "Please acknowledge the Response Agreement before submitting.")]
        public bool Acknowledged { get; set; }

        public static ValidationResult? ValidateBody(string? value, ValidationContext context)
        {
            var trimmed = value?.Trim() ?? string.Empty;

            if (trimmed.Length == 0)
            {
                return new ValidationResult("The Body field is required.", new[] { nameof(Body) });
            }

            if (trimmed.Length < 10)
            {
                return new ValidationResult(
                    "The Body field must be a string or array type with a minimum length of '10'.",
                    new[] { nameof(Body) });
            }

            return ValidationResult.Success;
        }

        public IEnumerable<ValidationResult> Validate(ValidationContext validationContext)
        {
            return Array.Empty<ValidationResult>();
        }
    }
}
